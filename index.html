<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D城市跑酷</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            touch-action: manipulation; /* 防止雙擊縮放 */
        }
        canvas {
            display: block;
        }
        .text-shadow {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        }
        /* 保持按鈕狀態一致性 */
        .btn-disabled {
            background-color: #9ca3af !important;
            cursor: not-allowed !important;
            transform: scale(1) !important;
        }
    </style>
</head>
<body class="bg-gray-800 flex items-center justify-center h-screen overflow-hidden">

    <div id="game-wrapper" class="w-full max-w-4xl aspect-[16/9] relative rounded-lg overflow-hidden shadow-2xl bg-black">
        <!-- Three.js canvas will be appended here by the script -->
        
        <!-- 遊戲中 UI -->
        <div id="game-ui" class="absolute top-4 left-4 text-white text-3xl font-bold text-shadow hidden">
            <p>分數: <span id="score">0</span></p>
            <p class="mt-2">金幣: <span id="coins-display">0</span></p>
        </div>

        <!-- 開始畫面 -->
        <div id="start-screen" class="absolute inset-0 bg-black bg-opacity-60 flex flex-col items-center justify-center text-white p-8">
            <h1 class="text-6xl md:text-8xl font-bold text-shadow mb-4">3D城市跑酷</h1>
            <p class="text-xl md:text-2xl text-shadow mb-4">按「空白鍵」或「點擊螢幕」跳躍</p>
            <p class="text-xl md:text-2xl text-shadow mb-8">按「A/D」或「←/→」左右移動</p>
            <div class="flex space-x-4">
                <button id="start-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-lg">
                    開始遊戲
                </button>
                <button id="shop-btn-start" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-lg">
                    商店
                </button>
            </div>
        </div>

        <!-- 遊戲結束畫面 -->
        <div id="game-over-screen" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center text-white p-8 hidden">
            <h2 class="text-5xl md:text-7xl font-bold text-shadow mb-4">遊戲結束</h2>
            <p class="text-2xl md:text-3xl text-shadow mb-2">最終分數</p>
            <p id="final-score" class="text-6xl font-bold text-shadow mb-8">0</p>
             <div class="flex space-x-4">
                <button id="restart-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-lg">
                    重新開始
                </button>
                 <button id="shop-btn-gameover" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-lg">
                    商店
                </button>
            </div>
        </div>
        
        <!-- 商店畫面 -->
        <div id="shop-screen" class="absolute inset-0 bg-gray-900 bg-opacity-95 flex-col items-center justify-center text-white p-8 hidden overflow-y-auto">
            <h2 class="text-5xl font-bold text-shadow mb-4">商店</h2>
            <p class="text-2xl mb-6">我的金幣: <span id="player-coins">0</span></p>
            <div id="shop-items-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                <!-- 商店物品會動態生成於此 -->
            </div>
            <button id="back-to-menu-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg text-xl transition-transform transform hover:scale-105 shadow-lg">
                返回
            </button>
        </div>
    </div>

    <script>
        // DOM 元素
        const gameWrapper = document.getElementById('game-wrapper');
        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('final-score');
        const gameUI = document.getElementById('game-ui');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const coinsDisplay = document.getElementById('coins-display');
        // 商店相關 DOM
        const shopScreen = document.getElementById('shop-screen');
        const shopBtnStart = document.getElementById('shop-btn-start');
        const shopBtnGameOver = document.getElementById('shop-btn-gameover');
        const playerCoinsEl = document.getElementById('player-coins');
        const shopItemsGrid = document.getElementById('shop-items-grid');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');

        // Three.js 變數
        let scene, camera, renderer, player, ground;
        let obstacles = [], buildings = [], coins = [];
        
        // 遊戲狀態變數
        let score, gameSpeed, isGameOver, animationFrameId;
        let playerVelocityY = 0;
        const gravity = -0.04;
        const jumpPower = 1.2;
        const lanes = [-4, 0, 4];
        let currentLane = 1;

        // 玩家資料
        let playerData = {};
        const shopItems = {
            'default': { name: '經典紅', price: 0, color: 0xe74c3c },
            'blue': { name: '海洋藍', price: 200, color: 0x3498db },
            'green': { name: '森林綠', price: 250, color: 0x2ecc71 },
            'yellow': { name: '陽光黃', price: 300, color: 0xf1c40f },
            'purple': { name: '神秘紫', price: 400, color: 0x9b59b6 },
            'white': { name: '時尚白', price: 500, color: 0xecf0f1 }
        };

        // --- 資料儲存 ---
        function loadPlayerData() {
            const savedData = localStorage.getItem('parkourPlayerData');
            if (savedData) {
                playerData = JSON.parse(savedData);
            } else {
                playerData = {
                    coins: 0,
                    unlockedSkins: ['default'],
                    equippedSkin: 'default'
                };
            }
        }

        function savePlayerData() {
            localStorage.setItem('parkourPlayerData', JSON.stringify(playerData));
        }

        // --- 商店邏輯 ---
        function openShop() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            shopScreen.classList.remove('hidden');
            renderShopItems();
        }

        function closeShop() {
             shopScreen.classList.add('hidden');
             // 判斷該回到哪個畫面
             if (isGameOver) {
                 gameOverScreen.classList.remove('hidden');
             } else {
                 startScreen.classList.remove('hidden');
             }
        }
        
        function renderShopItems() {
            playerCoinsEl.textContent = playerData.coins;
            shopItemsGrid.innerHTML = '';
            for (const id in shopItems) {
                const item = shopItems[id];
                const isUnlocked = playerData.unlockedSkins.includes(id);
                const isEquipped = playerData.equippedSkin === id;
                
                const itemEl = document.createElement('div');
                itemEl.className = 'flex flex-col items-center p-4 bg-gray-700 rounded-lg';
                
                const colorPreview = document.createElement('div');
                colorPreview.className = 'w-16 h-16 rounded-full mb-2 border-4 border-gray-500';
                colorPreview.style.backgroundColor = `#${new THREE.Color(item.color).getHexString()}`;
                
                const itemName = document.createElement('p');
                itemName.textContent = item.name;
                itemName.className = 'font-semibold';
                
                const button = document.createElement('button');
                button.className = 'mt-2 w-full text-white font-bold py-2 px-4 rounded transition-transform transform hover:scale-105';

                if (isEquipped) {
                    button.textContent = '已裝備';
                    button.classList.add('bg-gray-500', 'btn-disabled');
                } else if (isUnlocked) {
                    button.textContent = '裝備';
                    button.classList.add('bg-green-500', 'hover:bg-green-600');
                    button.onclick = () => equipSkin(id);
                } else {
                    button.textContent = `購買 (${item.price})`;
                     if (playerData.coins >= item.price) {
                        button.classList.add('bg-blue-500', 'hover:bg-blue-600');
                        button.onclick = () => buySkin(id);
                    } else {
                        button.classList.add('bg-gray-500', 'btn-disabled');
                    }
                }
                
                itemEl.appendChild(colorPreview);
                itemEl.appendChild(itemName);
                itemEl.appendChild(button);
                shopItemsGrid.appendChild(itemEl);
            }
        }

        function buySkin(id) {
            const item = shopItems[id];
            if (playerData.coins >= item.price && !playerData.unlockedSkins.includes(id)) {
                playerData.coins -= item.price;
                playerData.unlockedSkins.push(id);
                savePlayerData();
                renderShopItems();
            }
        }

        function equipSkin(id) {
            playerData.equippedSkin = id;
            savePlayerData();
            renderShopItems();
        }


        // --- 遊戲主邏輯 ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 150);

            const aspect = gameWrapper.clientWidth / gameWrapper.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 6, 12);
            camera.lookAt(0, 3, 0);

            if (renderer && renderer.domElement) {
                gameWrapper.removeChild(renderer.domElement);
            }
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(gameWrapper.clientWidth, gameWrapper.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            gameWrapper.insertBefore(renderer.domElement, gameWrapper.firstChild);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-30, 50, -30);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            scene.add(dirLight);

            player = new THREE.Group();
            const skinColor = shopItems[playerData.equippedSkin].color;
            const playerMat = new THREE.MeshStandardMaterial({ color: skinColor });

            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), playerMat);
            body.position.y = 1.75;
            body.castShadow = true;
            player.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), playerMat);
            head.position.y = 3;
            head.castShadow = true;
            player.add(head);
            player.userData.limbs = {};
            const legGeo = new THREE.BoxGeometry(0.4, 1.5, 0.4);
            const legL = new THREE.Mesh(legGeo, playerMat);
            legL.position.set(-0.3, 0.75, 0);
            legL.castShadow = true;
            player.userData.limbs.legL = legL;
            player.add(legL);
            const legR = new THREE.Mesh(legGeo, playerMat);
            legR.position.set(0.3, 0.75, 0);
            legR.castShadow = true;
            player.userData.limbs.legR = legR;
            player.add(legR);
            const armGeo = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            const armL = new THREE.Mesh(armGeo, playerMat);
            armL.position.set(-0.8, 2, 0);
            armL.castShadow = true;
            player.userData.limbs.armL = armL;
            player.add(armL);
            const armR = new THREE.Mesh(armGeo, playerMat);
            armR.position.set(0.8, 2, 0);
            armR.castShadow = true;
            player.userData.limbs.armR = armR;
            player.add(armR);
            scene.add(player);

            const groundGeo = new THREE.PlaneGeometry(30, 400);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            obstacles = [];
            buildings = [];
            coins = [];
            score = 0;
            gameSpeed = 0.3;
            isGameOver = false;
            currentLane = 1;
            player.position.set(lanes[currentLane], 0, 0);
            scoreEl.textContent = '0';
            coinsDisplay.textContent = playerData.coins;
            
            const objectsToRemove = [];
            scene.children.forEach(child => {
                if (child.userData.isObstacle || child.userData.isBuilding || child.userData.isCoin) {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(child => scene.remove(child));
        }

        function createBuilding() {
            const building = new THREE.Group();
            const width = 8 + Math.random() * 4;
            const height = 10 + Math.random() * 20;
            const depth = 8 + Math.random() * 4;
            const mainGeo = new THREE.BoxGeometry(width, height, depth);
            const colors = [0x5D6D7E, 0x808B96, 0xAEB6BF, 0xABB2B9];
            const mainMat = new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)] });
            const mainBlock = new THREE.Mesh(mainGeo, mainMat);
            mainBlock.position.y = height / 2;
            mainBlock.castShadow = true;
            mainBlock.receiveShadow = true;
            building.add(mainBlock);
            building.userData.depth = depth;
            building.userData.isBuilding = true;
            return building;
        }

        function createCoin() {
            const coinGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
            const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xccac00 });
            const coin = new THREE.Mesh(coinGeo, coinMat);
            coin.rotation.x = Math.PI / 2;
            coin.userData.isCoin = true;
            return coin;
        }

        function spawnThings() {
            if (obstacles.length === 0 || obstacles[obstacles.length-1].position.z > -100) {
                const obstacleGeo = new THREE.BoxGeometry(2, 2, 2);
                const obstacleMat = new THREE.MeshStandardMaterial({ color: 0x7f8c8d });
                const obstacle = new THREE.Mesh(obstacleGeo, obstacleMat);
                const lane = Math.floor(Math.random() * 3);
                obstacle.position.set(lanes[lane], 1, -150);
                obstacle.castShadow = true;
                obstacle.userData.isObstacle = true;
                obstacles.push(obstacle);
                scene.add(obstacle);

                // 在障礙物附近生成金幣串
                const coinLane = (lane + 1 + Math.floor(Math.random()*2)) % 3; // 選擇旁邊的跑道
                for (let i = 0; i < 5; i++) {
                    const coin = createCoin();
                    coin.position.set(lanes[coinLane], 2, -150 - i * 2);
                    coins.push(coin);
                    scene.add(coin);
                }
            }
            if (buildings.length === 0 || buildings[buildings.length-1].position.z > -100) {
                const buildingL = createBuilding();
                const buildingR = createBuilding();
                const lastBuildingZ = buildings.length > 0 ? buildings[buildings.length - 1].position.z : -150;
                const zPosL = lastBuildingZ - buildingL.userData.depth / 2 - (Math.random() * 10 + 5);
                buildingL.position.set(-12, 0, zPosL);
                buildings.push(buildingL);
                scene.add(buildingL);
                const zPosR = lastBuildingZ - buildingR.userData.depth / 2 - (Math.random() * 10 + 5);
                buildingR.position.set(12, 0, zPosR);
                buildings.push(buildingR);
                scene.add(buildingR);
            }
        }

        function checkCollision() {
            const playerBody = player.children[0];
            const playerBox = new THREE.Box3().setFromObject(playerBody, true);
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    endGame();
                    return;
                }
            }

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                const coinBox = new THREE.Box3().setFromObject(coin);
                if (playerBox.intersectsBox(coinBox)) {
                    playerData.coins++;
                    coinsDisplay.textContent = playerData.coins;
                    scene.remove(coin);
                    coins.splice(i, 1);
                }
            }
        }

        function animate() {
            if (isGameOver) return;

            playerVelocityY += gravity;
            player.position.y += playerVelocityY;
            if (player.position.y <= 0) {
                player.position.y = 0;
                playerVelocityY = 0;
            }
            const targetX = lanes[currentLane];
            player.position.x += (targetX - player.position.x) * 0.2;
            if (player.userData.limbs) {
                const time = Date.now() * 0.02;
                if (player.position.y <= 0.1) {
                    player.userData.limbs.legL.rotation.x = Math.sin(time) * 0.7;
                    player.userData.limbs.legR.rotation.x = -Math.sin(time) * 0.7;
                    player.userData.limbs.armL.rotation.x = -Math.sin(time) * 0.7;
                    player.userData.limbs.armR.rotation.x = Math.sin(time) * 0.7;
                } else {
                    player.userData.limbs.legL.rotation.x = 0.3;
                    player.userData.limbs.legR.rotation.x = -0.3;
                    player.userData.limbs.armL.rotation.x = -0.4;
                    player.userData.limbs.armR.rotation.x = 0.4;
                }
            }

            [...obstacles, ...buildings, ...coins].forEach(obj => {
                obj.position.z += gameSpeed;
            });
            spawnThings();
            
            for (let i = obstacles.length - 1; i >= 0; i--) { if(obstacles[i].position.z > camera.position.z) { scene.remove(obstacles[i]); obstacles.splice(i, 1); } }
            for (let i = buildings.length - 1; i >= 0; i--) { if(buildings[i].position.z > camera.position.z) { scene.remove(buildings[i]); buildings.splice(i, 1); } }
            for (let i = coins.length - 1; i >= 0; i--) { if(coins[i].position.z > camera.position.z) { scene.remove(coins[i]); coins.splice(i, 1); } }

            checkCollision();
            score++;
            scoreEl.textContent = score;
            gameSpeed += 0.0001;
            renderer.render(scene, camera);
            animationFrameId = requestAnimationFrame(animate);
        }

        function startGame() {
            init();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');
            animate();
        }

        function endGame() {
            isGameOver = true;
            savePlayerData();
            cancelAnimationFrame(animationFrameId);
            gameOverScreen.classList.remove('hidden');
            gameUI.classList.add('hidden');
            finalScoreEl.textContent = score;
        }
        
        function handleKey(e) {
             if (isGameOver || !player) return;
            if (e.code === 'Space' || e.type === 'mousedown' || e.type === 'touchstart') {
                e.preventDefault();
                if (player.position.y <= 0.1) { playerVelocityY = jumpPower; }
            } else if (e.code === 'KeyA' || e.code === 'ArrowLeft') {
                if (currentLane > 0) currentLane--;
            } else if (e.code === 'KeyD' || e.code === 'ArrowRight') {
                if (currentLane < 2) currentLane++;
            }
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = gameWrapper.clientWidth / gameWrapper.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(gameWrapper.clientWidth, gameWrapper.clientHeight);
            }
        }

        // --- 事件監聽 ---
        window.addEventListener('resize', onWindowResize);
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        shopBtnStart.addEventListener('click', openShop);
        shopBtnGameOver.addEventListener('click', openShop);
        backToMenuBtn.addEventListener('click', closeShop);
        
        document.addEventListener('keydown', handleKey);
        gameWrapper.addEventListener('mousedown', handleKey);
        gameWrapper.addEventListener('touchstart', handleKey);
        
        // --- 初始載入 ---
        loadPlayerData();

    </script>
</body>
</html>

